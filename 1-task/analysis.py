import matplotlib.pyplot as plt
import numpy as np
import math


# Явний метод Ейлера
def Euler(function, h, t0, tf, x0):  # задаємо назву методу,що залежить від рівняння; від кроку,
    # з яким його будемо розв'язувати; та початкового і кінцевого
    # часів розв'язку; та початкової умови
    # function - функція, задана дифрівнянням, яка визначає швидкість приросту координати
    n = math.ceil((tf - t0) / h)  # обчислюємо кількість кроків
    t = [round(t0 + i * h, 3) for i in range(n + 1)]  # Створюємо таблицю дискретного часу
    x = [x0]  # Створюємо масив, який поки що містить 1 елемент (нульовий елемент - початкова умова)
    # x1=[] Рядок формує заготовку для таблиці швидкостей зростання функції - 1 похідна
    for i in range(n):  # Заходимо в цикл, що складається з n кроків
        # x1=x1+[function(t[i], x[i])] Рядок заповнює таблицю швидкостей
        x = x + [round(x[i] + h * function(t[i], x[i]), 3)]
        # Додаємо до таблиці координат новобчислений елемент, що міститься в квадратних дужках
    return t, x, (h, t0, tf, x0, 'Explicit Euler')  # Результат, який отримаємо при виклику функції


# Неявний метод Ейлера
def EulerImp(function_implicit, h, t0, tf, x0):
    # задаємо назву методу,що залежить від рівняння; від кроку, з яким його будемо розв'язувати;
    # та початкового і кінцевого часів розв'язку; та початкової умови
    # functionImplicit - функція, виведена з дифрівняння для неявного методу Ейлера
    n = math.ceil((tf - t0) / h)  # обчислюємо кількість кроків
    t = [round(t0 + i * h, 3) for i in range(n + 1)]  # Створюємо таблицю дискретного часу
    x = [x0]  # Створюємо масив, який поки що містить 1 елемент (нульовий елемент - початкова умова)
    for i in range(n):  # Заходимо в цикл, що складається з n кроків
        x = x + [round(function_implicit(t[i + 1], x[i], h),
                       3)]  # Додаємо до таблиці координат новобчислений елемент, що міститься в квадратних дужках
    return t, x, (h, t0, tf, x0, 'Implicit Euler')  # Результат, який отримаємо при виклику функції


# Метод Рунге-Кути
def Runge(function, h, t0, tf, x0):
    # задаємо назву методу,що залежить від рівняння; від кроку, з яким його будемо розв'язувати;
    # та початкового і кінцевого часів розв'язку; та початкової умови
    # function - функція, задана дифрівнянням, яка визначає швидкість приросту координати
    n = math.ceil((tf - t0) / h)  # обчислюємо кількість кроків
    t = [round(t0 + i * h, 3) for i in range(n + 1)]  # Створюємо таблицю дискретного часу
    x = [x0]  # Створюємо масив, який поки що містить 1 елемент (нульовий елемент - початкова умова)
    # x1=[] Рядок формує заготовку для таблиці швидкостей зростання функції - 1 похідна
    for i in range(n):  # Заходимо в цикл, що складається з n кроків
        k1 = function(t[i], x[i])  # Обчислюємо к1 за м. Рунге-Кути 4 порядку
        k2 = function(t[i] + h / 2, x[i] + h * k1 / 2)
        k3 = function(t[i] + h / 2, x[i] + h * k2 / 2)
        k4 = function(t[i] + h, x[i] + h * k3)
        x = x + [round(x[i] + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4),
                       3)]  # Додаємо до таблиці координат новобчислений елемент, що міститься в квадратних дужках
    return t, x, (h, t0, tf, x0, 'Runge 4 order')  # Результат, який отримаємо при виклику функції


# Метод Адамса
def Adams2E(function, h, t0, tf,
            x0):  # задаємо назву методу,що залежить від рівняння; від кроку, з яким його будемо розв'язувати; та початкового і кінцевого часів розв'язку; та початкової умови
    # function - функція, задана дифрівнянням, яка визначає швидкість приросту координати
    n = math.ceil((tf - t0) / h)  # обчислюємо кількість кроків
    t = [round(t0 + i * h, 3) for i in range(n + 1)]  # Створюємо таблицю дискретного часу
    x = [x0]  # Створюємо масив, який поки що містить 1 елемент (нульовий елемент - початкова умова)
    # x1=[] Рядок формує заготовку для таблиці швидкостей зростання функції - 1 похідна
    # Перший крок робимо за Рунге
    i = 0
    k1 = function(t[i], x[i])  # Обчислюємо к1 за м. Рунге-Кути 4 порядку
    k2 = function(t[i] + h / 2, x[i] + h * k1 / 2)
    k3 = function(t[i] + h / 2, x[i] + h * k2 / 2)
    k4 = function(t[i] + h, x[i] + h * k3)
    x = x + [round(x[i] + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4),
                   3)]  # Додаємо до таблиці координат новобчислений елемент, що міститься в квадратних дужках
    for i in range(n - 1):  # Заходимо в цикл, що складається з (n-1) кроків
        x = x + [round(x[i + 1] + 3 / 2 * h * function(t[i + 1], x[i + 1]) - h / 2 * function(t[i], x[i]), 3)]
    return t, x, (h, t0, tf, x0, 'Adams 2-points Explicit')  # Результат, який отримаємо при виклику функції


# Неявний метод Адамса
def Adams2I(functionImplicitAdams, function, h, t0, tf, x0):
    # задаємо назву методу,що залежить від рівняння; від кроку, з яким його будемо розв'язувати;
    # та початкового і кінцевого часів розв'язку; та початкової умови
    # functionImplicit - функція, виведена з дифрівняння для неявного методу Ейлера
    n = math.ceil((tf - t0) / h)  # обчислюємо кількість кроків
    t = [round(t0 + i * h, 3) for i in range(n + 1)]  # Створюємо таблицю дискретного часу
    x = [x0]  # Створюємо масив, який поки що містить 1 елемент (нульовий елемент - початкова умова)
    # Перший крок робимо за Рунге
    i = 0
    k1 = function(t[i], x[i])  # Обчислюємо к1 за м. Рунге-Кути 4 порядку
    k2 = function(t[i] + h / 2, x[i] + h * k1 / 2)
    k3 = function(t[i] + h / 2, x[i] + h * k2 / 2)
    k4 = function(t[i] + h, x[i] + h * k3)
    x = x + [round(x[i] + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4),
                   3)]  # Додаємо до таблиці координат новобчислений елемент, що міститься в квадратних дужках
    for i in range(n - 1):  # Заходимо в цикл, що складається з (n-1) кроків
        x = x + [round(functionImplicitAdams(t[i], x[i], x[i + 1], h), 3)]
    # Додаємо до таблиці координат новобчислений елемент, що міститься в квадратних дужках t[i+1]=t[i]+h, t[i+2]=t[i]+2*h
    return t, x, (h, t0, tf, x0, 'Adams 2-points Implicit')  # Результат, який отримаємо при виклику функції


def Tochnist1(Method, function, solution, H, t0, tf, x0):
    # задаємо назву методу, буде розв'язувати задане рівняння при даній початковій умові з різними кроками з масиву Н, додатково треба буде задати аналітичний розв'язок
    Error = []  # Створюємо порожній масив, як заготовку для значень похибки
    for i in range(len(H)):
        # Входимо в цикл, кількість повторень - кількість елементів в масиві кроків, які хочемо проаналізувати
        (T, X, Opis) = Method(function, H[i], t0, tf, x0)  # З і-м кроком розв'язуємо рівняння заданим методом
        Sol = [round(solution(T[i]), 3) for i in range(len(T))]  # Таблиця значень функції аналітичного розв'язку
        Error = Error + [round(math.sqrt(np.sum([(Sol[i] - X[i]) ** 2 for i in range(len(T))]) / (len(T))), 5)]
        # Додаємо до таблиці похибок новобчислений елемент, що міститься в квадратних дужках
        # Округлений до 5 знаків після коми орінь з відношення суми елементів масиву ([(Sol[i]-X[i])**2 for i in range(len(T))]), що складається з квадратів різниць точних та чисельних значень, до кількості елементів
    fig, a = plt.subplots()
    a.plot(H, Error)
    plt.title('Dependence of the error of ' + Opis[4] + ' method on time step')
    plt.ylabel('Error')
    plt.xlabel('Time step')
    plt.grid(True)
    return H, Error, (t0, tf, x0, Opis[4])


def Tochnist1Ad2I(Method, functionImplicitAdams, function, solution, H, t0, tf,
                  x0):  # задаємо назву методу, буде розв'язувати задане рівняння при даній початковій умові з різними кроками з масиву Н, додатково треба буде задати аналітичний розв'язок
    Error = []  # Створюємо порожній масив, як заготовку для значень похибки
    for i in range(
            len(H)):  # Входимо в цикл, кількість повторень - кількість елементів в масиві кроків, які хочемо проаналізувати
        (T, X, Opis) = Method(functionImplicitAdams, function, H[i], t0, tf,
                              x0)  # З і-м кроком розв'язуємо рівняння заданим методом
        Sol = [round(solution(T[i]), 3) for i in range(len(T))]  # Таблиця значень функції аналітичного розв'язку
        Error = Error + [round(math.sqrt(np.sum([(Sol[i] - X[i]) ** 2 for i in range(len(T))]) / (len(T))),
                               5)]  # Додаємо до таблиці похибок новобчислений елемент, що міститься в квадратних дужках
        # Округлений до 5 знаків після коми орінь з відношення суми елементів масиву ([(Sol[i]-X[i])**2 for i in range(len(T))]), що складається з квадратів різниць точних та чисельних значень, до кількості елементів
    fig, a = plt.subplots()
    a.plot(H, Error)
    plt.title('Dependence of the error of ' + Opis[4] + ' method on time step')
    plt.ylabel('Error')
    plt.xlabel('Time step')
    plt.grid(True)
    return H, Error, (t0, tf, x0, Opis[4])


def f1(t, x):
    return 0.4 * t - 3 * math.sqrt(t) + math.exp(0.3 * t)  # Функція, задана дифрівнянням


H = [0.01, 0.05, 0.1, 0.3, 0.5]


def solution(t):
    return -4 / 3 + 10 / 3 * math.exp(0.3 * t) - 2 * t ** (3 / 2) + 0.2 * t * t
    # Функція, що описує аналітичний розв'язок заданого рівняння


def f1ImpEu(t, x, h):
    return x + (0.4 * t - 3 * math.sqrt(t) + math.exp(0.3 * t)) * h
    # Функція, виведена з дифрівняння 1 для неявного методу Ейлера
